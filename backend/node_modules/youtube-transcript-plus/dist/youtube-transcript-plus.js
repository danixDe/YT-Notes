import fs from 'fs/promises';
import path from 'path';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const DEFAULT_USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36';
const RE_YOUTUBE = /(?:v=|\/|v\/|embed\/|watch\?.*v=|youtu\.be\/|\/v\/|e\/|watch\?.*vi?=|\/embed\/|\/v\/|vi?\/|watch\?.*vi?=|youtu\.be\/|\/vi?\/|\/e\/)([a-zA-Z0-9_-]{11})/i;
const RE_XML_TRANSCRIPT = /<text start="([^"]*)" dur="([^"]*)">([^<]*)<\/text>/g;

class YoutubeTranscriptTooManyRequestError extends Error {
    constructor() {
        super('YouTube is receiving too many requests from your IP address. Please try again later or use a proxy. If the issue persists, consider reducing the frequency of requests.');
        this.name = 'YoutubeTranscriptTooManyRequestError';
    }
}
class YoutubeTranscriptVideoUnavailableError extends Error {
    constructor(videoId) {
        super(`The video with ID "${videoId}" is no longer available or has been removed. Please check the video URL or ID and try again.`);
        this.name = 'YoutubeTranscriptVideoUnavailableError';
    }
}
class YoutubeTranscriptDisabledError extends Error {
    constructor(videoId) {
        super(`Transcripts are disabled for the video with ID "${videoId}". This may be due to the video owner disabling captions or the video not supporting transcripts.`);
        this.name = 'YoutubeTranscriptDisabledError';
    }
}
class YoutubeTranscriptNotAvailableError extends Error {
    constructor(videoId) {
        super(`No transcripts are available for the video with ID "${videoId}". This may be because the video does not have captions or the captions are not accessible.`);
        this.name = 'YoutubeTranscriptNotAvailableError';
    }
}
class YoutubeTranscriptNotAvailableLanguageError extends Error {
    constructor(lang, availableLangs, videoId) {
        super(`No transcripts are available in "${lang}" for the video with ID "${videoId}". Available languages: ${availableLangs.join(', ')}. Please try a different language.`);
        this.name = 'YoutubeTranscriptNotAvailableLanguageError';
    }
}
class YoutubeTranscriptInvalidVideoIdError extends Error {
    constructor() {
        super('Invalid YouTube video ID or URL. Please provide a valid video ID or URL. Example: "dQw4w9WgXcQ" or "https://www.youtube.com/watch?v=dQw4w9WgXcQ".');
        this.name = 'YoutubeTranscriptInvalidVideoIdError';
    }
}

function retrieveVideoId(videoId) {
    if (videoId.length === 11) {
        return videoId;
    }
    const matchId = videoId.match(RE_YOUTUBE);
    if (matchId && matchId.length) {
        return matchId[1];
    }
    throw new YoutubeTranscriptInvalidVideoIdError();
}
function defaultFetch(_a) {
    return __awaiter(this, arguments, void 0, function* ({ url, lang, userAgent, }) {
        return fetch(url, {
            headers: Object.assign(Object.assign({}, (lang && { 'Accept-Language': lang })), { 'User-Agent': userAgent || DEFAULT_USER_AGENT }),
        });
    });
}

class FsCache {
    constructor(cacheDir = './cache', defaultTTL = 3600000) {
        this.cacheDir = cacheDir;
        this.defaultTTL = defaultTTL;
        fs.mkdir(cacheDir, { recursive: true }).catch(() => { });
    }
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = path.join(this.cacheDir, key);
            try {
                const data = yield fs.readFile(filePath, 'utf-8');
                const { value, expires } = JSON.parse(data);
                if (expires > Date.now()) {
                    return value;
                }
                yield fs.unlink(filePath);
            }
            catch (error) { }
            return null;
        });
    }
    set(key, value, ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = path.join(this.cacheDir, key);
            const expires = Date.now() + (ttl !== null && ttl !== void 0 ? ttl : this.defaultTTL);
            yield fs.writeFile(filePath, JSON.stringify({ value, expires }), 'utf-8');
        });
    }
}

class InMemoryCache {
    constructor(defaultTTL = 3600000) {
        this.cache = new Map();
        // 1 hour default TTL
        this.defaultTTL = defaultTTL;
    }
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const entry = this.cache.get(key);
            if (entry && entry.expires > Date.now()) {
                return entry.value;
            }
            this.cache.delete(key); // Clean up expired entries
            return null;
        });
    }
    set(key, value, ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            const expires = Date.now() + (ttl !== null && ttl !== void 0 ? ttl : this.defaultTTL);
            this.cache.set(key, { value, expires });
        });
    }
}

class YoutubeTranscript {
    constructor(config) {
        this.config = config;
    }
    fetchTranscript(videoId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
            const identifier = retrieveVideoId(videoId);
            const userAgent = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.userAgent) || DEFAULT_USER_AGENT;
            // Use custom fetch functions if provided, otherwise use defaultFetch
            const videoFetch = ((_b = this.config) === null || _b === void 0 ? void 0 : _b.videoFetch) || defaultFetch;
            const transcriptFetch = ((_c = this.config) === null || _c === void 0 ? void 0 : _c.transcriptFetch) || defaultFetch;
            // Cache key based on video ID and language
            const cacheKey = `transcript:${identifier}:${((_d = this.config) === null || _d === void 0 ? void 0 : _d.lang) || 'default'}`;
            // Check cache first
            if ((_e = this.config) === null || _e === void 0 ? void 0 : _e.cache) {
                const cachedTranscript = yield this.config.cache.get(cacheKey);
                if (cachedTranscript) {
                    return JSON.parse(cachedTranscript);
                }
            }
            const protocol = ((_f = this.config) === null || _f === void 0 ? void 0 : _f.disableHttps) ? 'http' : 'https';
            // Fetch the video page
            const videoPageResponse = yield videoFetch({
                url: `${protocol}://www.youtube.com/watch?v=${identifier}`,
                lang: (_g = this.config) === null || _g === void 0 ? void 0 : _g.lang,
                userAgent,
            });
            if (!videoPageResponse.ok) {
                throw new YoutubeTranscriptVideoUnavailableError(identifier);
            }
            const videoPageBody = yield videoPageResponse.text();
            // Parse the video page to extract captions
            const splittedHTML = videoPageBody.split('"captions":');
            if (splittedHTML.length <= 1) {
                if (videoPageBody.includes('class="g-recaptcha"')) {
                    throw new YoutubeTranscriptTooManyRequestError();
                }
                if (!videoPageBody.includes('"playabilityStatus":')) {
                    throw new YoutubeTranscriptVideoUnavailableError(identifier);
                }
                throw new YoutubeTranscriptDisabledError(identifier);
            }
            const captions = (_h = (() => {
                try {
                    return JSON.parse(splittedHTML[1].split(',"videoDetails')[0].replace('\n', ''));
                }
                catch (e) {
                    return undefined;
                }
            })()) === null || _h === void 0 ? void 0 : _h['playerCaptionsTracklistRenderer'];
            if (!captions) {
                throw new YoutubeTranscriptDisabledError(identifier);
            }
            if (!('captionTracks' in captions)) {
                throw new YoutubeTranscriptNotAvailableError(identifier);
            }
            if (((_j = this.config) === null || _j === void 0 ? void 0 : _j.lang) &&
                !captions.captionTracks.some((track) => { var _a; return track.languageCode === ((_a = this.config) === null || _a === void 0 ? void 0 : _a.lang); })) {
                throw new YoutubeTranscriptNotAvailableLanguageError((_k = this.config) === null || _k === void 0 ? void 0 : _k.lang, captions.captionTracks.map((track) => track.languageCode), identifier);
            }
            const captionURL = (((_l = this.config) === null || _l === void 0 ? void 0 : _l.lang)
                ? captions.captionTracks.find((track) => { var _a; return track.languageCode === ((_a = this.config) === null || _a === void 0 ? void 0 : _a.lang); })
                : captions.captionTracks[0]).baseUrl;
            const transcriptURL = ((_m = this.config) === null || _m === void 0 ? void 0 : _m.disableHttps)
                ? captionURL.replace('https://', 'http://')
                : captionURL;
            // Fetch the transcript
            const transcriptResponse = yield transcriptFetch({
                url: transcriptURL,
                lang: (_o = this.config) === null || _o === void 0 ? void 0 : _o.lang,
                userAgent,
            });
            if (!transcriptResponse.ok) {
                throw new YoutubeTranscriptNotAvailableError(identifier);
            }
            const transcriptBody = yield transcriptResponse.text();
            const results = [...transcriptBody.matchAll(RE_XML_TRANSCRIPT)];
            const transcript = results.map((result) => {
                var _a, _b;
                return ({
                    text: result[3],
                    duration: parseFloat(result[2]),
                    offset: parseFloat(result[1]),
                    lang: (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.lang) !== null && _b !== void 0 ? _b : captions.captionTracks[0].languageCode,
                });
            });
            // Store in cache if a strategy is provided
            if ((_p = this.config) === null || _p === void 0 ? void 0 : _p.cache) {
                yield this.config.cache.set(cacheKey, JSON.stringify(transcript), this.config.cacheTTL);
            }
            return transcript;
        });
    }
    // Add static method for new usage pattern
    static fetchTranscript(videoId, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const instance = new YoutubeTranscript(config);
            return instance.fetchTranscript(videoId);
        });
    }
}
// Export the static method directly for convenience
const fetchTranscript = YoutubeTranscript.fetchTranscript;

export { FsCache, InMemoryCache, YoutubeTranscript, YoutubeTranscriptDisabledError, YoutubeTranscriptInvalidVideoIdError, YoutubeTranscriptNotAvailableError, YoutubeTranscriptNotAvailableLanguageError, YoutubeTranscriptTooManyRequestError, YoutubeTranscriptVideoUnavailableError, fetchTranscript };
